{:title "Macros"
 :template "docpage.html"
 :order 10}
---

Janet supports macros: routines that take code as input and return transformed
code as output. A macro is like a function, but transforms the code itself
rather than data, so it is more flexible in what it can do than a function.
Macros let you extend the syntax of the language itself.

You have seen some macros already. The @code[let], @code[loop], and @code[defn]
forms are macros. When the compiler sees a macro, it evaluates the macro and
then compiles the result. We say the macro has been @strong{expanded} after the
compiler evaluates it. A simple version of the @code[defn] macro can be thought
of as transforming code of the form

@codeblock[janet](```
(defn1 myfun [x] body)
```)

into

@codeblock[janet](```
(def myfun (fn myfun [x] body))
```)

We could write such a macro like so:

@codeblock[janet](```
(defmacro defn1 [name args body]
 (tuple 'def name (tuple 'fn name args body)))
```)

There are a couple of issues with this macro, but it will work for simple
functions quite well.

The first issue is that our @code`defn1` macro can't define functions with
multiple expressions in the body. We can make the macro variadic, just like a
function. Here is a second version of this macro:

@codeblock[janet](```
(defmacro defn2 [name args & body]
 (tuple 'def name (apply tuple 'fn name args body)))
```)

Great! Now we can define functions with multiple elements in the body.

We can still improve this macro even more though. First, we can add a docstring
to it. If someone is using the function later, they can use @code[(doc defn3)]
to get a description of the function. Next, we can rewrite the macro using
Janet's builtin quasiquoting facilities.

@codeblock[janet](```
(defmacro defn3
 "Defines a new function."
 [name args & body]
 ~(def ,name (fn ,name ,args ,;body)))
```)

This is functionally identical to our previous version @code[defn2], but written
in such a way that the macro output is more clear. The leading tilde @code[~] is
shorthand for the @code[(quasiquote x)] special form, which is like @code[(quote
x)] except we can unquote expressions inside it. The comma in front of
@code[name] and @code[args] is an unquote, which allows us to put a value in the
quasiquote. Without the unquote, the symbol @code`name` would be put in the
returned tuple, and every function we defined would be called @code`name`!

Similar to @code`name`, we must also unquote @code`body`. However, a normal
unquote doesn't work.  See what happens if we use a normal unquote for
@code`body` as well.

@codeblock[janet](```
(def name 'myfunction)
(def args '[x y z])
(defn body '[(print x) (print y) (print z)])

~(def ,name (fn ,name ,args ,body))
# -> (def myfunction (fn myfunction (x y z) ((print x) (print y) (print z))))
```)

There is an extra set of parentheses around the body of our function! We don't
want to put the body @strong{inside} the form @code[(fn args ...)], we want to
@strong{splice} it into the form. Luckily, Janet has the @code[(splice x)]
special form for this purpose, and a shorthand for it, the @code`;` character.
When combined with the unquote special, we get the desired output:

@codeblock[janet](```
~(def ,name (fn ,name ,args ,;body))
# -> (def myfunction (fn myfunction (x y z) (print x) (print y) (print z)))
```)

## Hygiene

Sometimes when we write macros, we must generate symbols for local bindings.
Ignoring that this could be written as a function, consider the following macro:

@codeblock[janet](```
(defmacro max1
 "Get the max of two values."
 [x y]
 ~(if (> ,x ,y) ,x ,y))
```)

This almost works, but will evaluate both @code`x` and @code`y` twice. This is
because both show up in the macro twice. For example, @code[(max1 (do (print 1)
1) (do (print 2) 2))] will print both 1 and 2 twice, which would be surprising
to a user of this macro.

We can do better:

@codeblock[janet](```
(defmacro max2
 "Get the max of two values."
 [x y]
 ~(let [x ,x
        y ,y]
    (if (> x y) x y)))
```)

Now we have no double evaluation problem! But we now have an even more subtle
problem.  What happens in the following code?

@codeblock[janet](```
(def x 10)
(max2 8 (+ x 4))
```)

We want the maximum to be 14, but this will actually evaluate to 12! This can be
understood if we expand the macro. You can expand a macro once in Janet using
the @code[(macex1 x)] function.  (To expand macros until there are no macros
left to expand, use @code[(macex x)]. Be careful: Janet has many macros, so the
full expansion may be almost unreadable).

@codeblock[janet](```
(macex1 '(max2 8 (+ x 4)))
# -> (let (x 8 y (+ x 4)) (if (> x y) x y))
```)

After expansion, @code`y` wrongly refers to the @code`x` inside the macro (which
is bound to 8) rather than the @code`x` defined to be 10. The problem is the
reuse of the symbol @code`x` inside the macro, which overshadowed the original
binding. This problem is called the
@link[https://en.wikipedia.org/wiki/Hygienic_macro#The_hygiene_problem]{hygiene
problem} and is well known in many programming languages. Some languages provide
complicated solutions to this problem, but Janet opts for a much
simpler&mdash;if not primitive&mdash;solution.

Janet provides a general solution to this problem in terms of the
@code[(gensym)] function, which returns a symbol which is guaranteed to be
unique and not collide with any symbols defined previously. We can define our
macro once more for a fully correct macro.

@codeblock[janet](```janet
(defmacro max3
 "Get the max of two values."
 [x y]
 (def $x (gensym))
 (def $y (gensym))
 ~(let [,$x ,x
        ,$y ,y]
    (if (> ,$x ,$y) ,$x ,$y)))
```)

Since it is quite common to create several gensyms for use inside a macro body,
Janet provides a macro @code[with-syms] to make this definition a bit terser.

@codeblock[janet](```
(defmacro max4
 "Get the max of two values."
 [x y]
 (with-syms [$x $y]
   ~(let [,$x ,x
          ,$y ,y]
      (if (> ,$x ,$y) ,$x ,$y))))
```)

As you can see, macros are very powerful but are also prone to subtle bugs. You
must remember that at their core, macros are just functions that output code,
and the code that they return must work in many contexts! Many times a function
will suffice and be more useful that a macro, as functions can be more easily
passed around and used as first class values.
