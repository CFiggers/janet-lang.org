
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Janet Language Documentation</title>
<meta name="description" content="API Documentation for the janet programming language.">
<style>
.docstring {
  font-family: monospace;
}
.binding-type {
  color: blue;
}
.source-map {
  color: steelblue;
  font-size: 0.8em;
}
</style>
</head>
<h1>Janet Core API</h1><p>Version 0.3.0-1304f92</p><p>Generated 1547579368 seconds after epoch</p><hr><h2 class="binding">%</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(% dividend divisor)<br><br>Returns the remainder of dividend &#47; divisor.</p>
<hr>
<h2 class="binding">%=</h2>
<span class="binding-type">macro</span>
<p class="docstring">(%= x n)<br><br>Shorthand for (set x (% x n)).</p>
<span class="source-map">core.janet (5311:5383)</span><hr>
<h2 class="binding">*</h2>
<span class="binding-type">function</span>
<p class="docstring">(* &amp; xs)<br><br>Returns the product of all elements in xs. If xs is empty, returns 1.</p>
<hr>
<h2 class="binding">*=</h2>
<span class="binding-type">macro</span>
<p class="docstring">(*= x n)<br><br>Shorthand for (set x (* x n)).</p>
<span class="source-map">core.janet (5163:5235)</span><hr>
<h2 class="binding">*doc-width*</h2>
<span class="binding-type">var (number)</span>
<p class="docstring">Width in columns to print documentation.</p>
<span class="source-map">core.janet (37020:37086)</span><hr>
<h2 class="binding">*env*</h2>
<span class="binding-type">var (table)</span>
<p class="docstring">The current environment.</p>
<span class="source-map">core.janet (108:154)</span><hr>
<h2 class="binding">+</h2>
<span class="binding-type">function</span>
<p class="docstring">(+ &amp; xs)<br><br>Returns the sum of all xs. xs must be integers or real numbers only. If xs is empty, return 0.</p>
<hr>
<h2 class="binding">++</h2>
<span class="binding-type">macro</span>
<p class="docstring">(++ x)<br><br>Increments the var x by 1.</p>
<span class="source-map">core.janet (4887:4953)</span><hr>
<h2 class="binding">+=</h2>
<span class="binding-type">macro</span>
<p class="docstring">(+= x n)<br><br>Increments the var x by n.</p>
<span class="source-map">core.janet (5023:5091)</span><hr>
<h2 class="binding">-</h2>
<span class="binding-type">function</span>
<p class="docstring">(- &amp; xs)<br><br>Returns the difference of xs. If xs is empty, returns 0. If xs has one element, returns the negative value of that element. Otherwise, returns the first element in xs minus the sum of the rest of the elements.</p>
<hr>
<h2 class="binding">--</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-- x)<br><br>Decrements the var x by 1.</p>
<span class="source-map">core.janet (4955:5021)</span><hr>
<h2 class="binding">-=</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-= x n)<br><br>Decrements the var x by n.</p>
<span class="source-map">core.janet (5093:5161)</span><hr>
<h2 class="binding">-&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-&gt; x &amp; forms)<br><br>Threading macro. Inserts x as the second value in the first form  in forms, and inserts the modified first form into the second form  in the same manner, and so on. Useful for expressing pipelines of data.</p>
<span class="source-map">core.janet (26351:26828)</span><hr>
<h2 class="binding">-&gt;&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-&gt;&gt; x &amp; forms)<br><br>Threading macro. Inserts x as the last value in the first form  in forms, and inserts the modified first form into the second form  in the same manner, and so on. Useful for expressing pipelines of data.</p>
<span class="source-map">core.janet (26831:27310)</span><hr>
<h2 class="binding">-?&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-?&gt; x &amp; forms)<br><br>Short circuit threading macro. Inserts x as the last value in the first form  in forms, and inserts the modified first form into the second form  in the same manner, and so on. The pipeline will return nil  if an intermediate value is nil.  Useful for expressing pipelines of data.</p>
<span class="source-map">core.janet (27313:27922)</span><hr>
<h2 class="binding">-?&gt;&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(-?&gt;&gt; x &amp; forms)<br><br>Threading macro. Inserts x as the last value in the first form  in forms, and inserts the modified first form into the second form  in the same manner, and so on. The pipeline will return nil  if an intermediate value is nil.  Useful for expressing pipelines of data.</p>
<span class="source-map">core.janet (27925:28524)</span><hr>
<h2 class="binding">&#47;</h2>
<span class="binding-type">function</span>
<p class="docstring">(&#47; &amp; xs)<br><br>Returns the quotient of xs. If xs is empty, returns 1. If xs has one value x, returns the reciprocal of x. Otherwise return the first value of xs repeatedly divided by the remaining values. Division by two integers uses truncating division.</p>
<hr>
<h2 class="binding">&#47;=</h2>
<span class="binding-type">macro</span>
<p class="docstring">(&#47;= x n)<br><br>Shorthand for (set x (&#47; x n)).</p>
<span class="source-map">core.janet (5237:5309)</span><hr>
<h2 class="binding">&lt;</h2>
<span class="binding-type">function</span>
<p class="docstring">(&lt; &amp; xs)<br><br>Check if xs is in numerically ascending order. Returns a boolean.</p>
<hr>
<h2 class="binding">&lt;=</h2>
<span class="binding-type">function</span>
<p class="docstring">(&lt;= &amp; xs)<br><br>Check if xs is in numerically non-descending order. Returns a boolean.</p>
<hr>
<h2 class="binding">=</h2>
<span class="binding-type">function</span>
<p class="docstring">(= &amp; xs)<br><br>Returns true if all values in xs are the same, false otherwise.</p>
<hr>
<h2 class="binding">==</h2>
<span class="binding-type">function</span>
<p class="docstring">(== &amp; xs)<br><br>Check if all values in xs are numerically equal (4.0 == 4). Returns a boolean.</p>
<hr>
<h2 class="binding">&gt;</h2>
<span class="binding-type">function</span>
<p class="docstring">(&gt; &amp; xs)<br><br>Check if xs is in numerically descending order. Returns a boolean.</p>
<hr>
<h2 class="binding">&gt;=</h2>
<span class="binding-type">function</span>
<p class="docstring">(&gt;= &amp; xs)<br><br>Check if xs is in numerically non-ascending order. Returns a boolean.</p>
<hr>
<h2 class="binding">_env</h2>
<span class="binding-type">table</span>
<p class="docstring">The environment table for the current scope.</p>
<hr>
<h2 class="binding">abstract?</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(abstract? x)<br><br>Check if x is an abstract type.</p>
<hr>
<h2 class="binding">all</h2>
<span class="binding-type">function</span>
<p class="docstring">(all pred xs)<br><br>Returns true if all xs are truthy, otherwise the first false or nil value.</p>
<span class="source-map">core.janet (41009:41182)</span><hr>
<h2 class="binding">all-bindings</h2>
<span class="binding-type">function</span>
<p class="docstring">(all-bindings env &amp;)<br><br>Get all symbols available in the current environment.</p>
<span class="source-map">core.janet (51963:52316)</span><hr>
<h2 class="binding">and</h2>
<span class="binding-type">macro</span>
<p class="docstring">(and &amp; forms)<br><br>Evaluates to the last argument if all preceding elements are true, otherwise  evaluates to false.</p>
<span class="source-map">core.janet (8216:8541)</span><hr>
<h2 class="binding">apply</h2>
<span class="binding-type">function</span>
<p class="docstring">(apply f &amp; args)<br><br>Applies a function to a variable number of arguments. Each element in args is used as an argument to f, except the last element in args, which is expected to be an array-like. Each element in this last argument is then also pushed as an argument to f. For example:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(apply + 1000 (range 10))<br><br>sums the first 10 integers and 1000.)</p>
<hr>
<h2 class="binding">array</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array &amp; items)<br><br>Create a new array that contains items. Returns the new array.</p>
<hr>
<h2 class="binding">array&#47;concat</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;concat arr &amp; parts)<br><br>Concatenates a variadic number of arrays (and tuples) into the first argument which must an array. If any of the parts are arrays or tuples, their elements will be inserted into the array. Otherwise, each part in parts will be appended to arr in order. Return the modified array arr.</p>
<hr>
<h2 class="binding">array&#47;ensure</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;ensure arr capacity)<br><br>Ensures that the memory backing the array has enough memory for capacity items. Capacity must be an integer. If the backing capacity is already enough, then this function does nothing. Otherwise, the backing memory will be reallocated so that there is enough space.</p>
<hr>
<h2 class="binding">array&#47;insert</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;insert arr at &amp; xs)<br><br>Insert all of xs into array arr at index at. at should be an integer 0 and the length of the array. A negative value for at will index from the end of the array, such that inserting at -1 appends to the array. Returns the array.</p>
<hr>
<h2 class="binding">array&#47;new</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;new capacity)<br><br>Creates a new empty array with a pre-allocated capacity. The same as (array) but can be more efficient if the maximum size of an array is known.</p>
<hr>
<h2 class="binding">array&#47;peek</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;peek arr)<br><br>Returns the last element of the array. Does not modify the array.</p>
<hr>
<h2 class="binding">array&#47;pop</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;pop arr)<br><br>Remove the last element of the array and return it. If the array is empty, will return nil. Modifies the input array.</p>
<hr>
<h2 class="binding">array&#47;push</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;push arr x)<br><br>Insert an element in the end of an array. Modifies the input array and returns it.</p>
<hr>
<h2 class="binding">array&#47;slice</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(array&#47;slice arrtup [, start=0 [, end=(length arrtup)]])<br><br>Takes a slice of array or tuple from start to end. The range is half open, [start, end). Indexes can also be negative, indicating indexing from the end of the end of the array. By default, start is 0 and end is the length of the array. Returns a new array.</p>
<hr>
<h2 class="binding">array?</h2>
<span class="binding-type">function</span>
<p class="docstring">(array? x)<br><br>Check if x is an array.</p>
<span class="source-map">core.janet (2892:2954)</span><hr>
<h2 class="binding">as-&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(as-&gt; x as &amp; forms)<br><br>Thread forms together, replacing as in forms with the value  of the previous form. The first for is the value x. Returns the  last value.</p>
<span class="source-map">core.janet (29464:29821)</span><hr>
<h2 class="binding">as?-&gt;</h2>
<span class="binding-type">macro</span>
<p class="docstring">(as?-&gt; x as &amp; forms)<br><br>Thread forms together, replacing as in forms with the value  of the previous form. The first for is the value x. If any  intermediate values are falsey, return nil; otherwise, returns the  last value.</p>
<span class="source-map">core.janet (29824:30249)</span><hr>
<h2 class="binding">asm</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(asm assembly)<br><br>Returns a new function that is the compiled result of the assembly.<br>The syntax for the assembly can be found on the janet wiki. Will throw an<br>error on invalid assembly.</p>
<hr>
<h2 class="binding">band</h2>
<span class="binding-type">function</span>
<p class="docstring">(band &amp; xs)<br><br>Returns the bit-wise and of all values in xs. Each x in xs must be an integer.</p>
<hr>
<h2 class="binding">blshift</h2>
<span class="binding-type">function</span>
<p class="docstring">(blshift x &amp; shifts)<br><br>Returns the value of x bit shifted left by the sum of all values in shifts. x and each element in shift must be an integer.</p>
<hr>
<h2 class="binding">bnot</h2>
<span class="binding-type">function</span>
<p class="docstring">(bnot x)<br><br>Returns the bit-wise inverse of integer x.</p>
<hr>
<h2 class="binding">boolean?</h2>
<span class="binding-type">function</span>
<p class="docstring">(boolean? x)<br><br>Check if x is a boolean.</p>
<span class="source-map">core.janet (3019:3086)</span><hr>
<h2 class="binding">bor</h2>
<span class="binding-type">function</span>
<p class="docstring">(bor &amp; xs)<br><br>Returns the bit-wise or of all values in xs. Each x in xs must be an integer.</p>
<hr>
<h2 class="binding">brshift</h2>
<span class="binding-type">function</span>
<p class="docstring">(brshift x &amp; shifts)<br><br>Returns the value of x bit shifted right by the sum of all values in shifts. x and each element in shift must be an integer.</p>
<hr>
<h2 class="binding">brushift</h2>
<span class="binding-type">function</span>
<p class="docstring">(brushift x &amp; shifts)<br><br>Returns the value of x bit shifted right by the sum of all values in shifts. x and each element in shift must be an integer. The sign of x is not preserved, so for positive shifts the return value will always be positive.</p>
<hr>
<h2 class="binding">buffer</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer &amp; xs)<br><br>Creates a new buffer by concatenating values together. Values are converted to bytes via describe if they are not byte sequences. Returns the new buffer.</p>
<hr>
<h2 class="binding">buffer&#47;bit</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;bit buffer index)<br><br>Gets the bit at the given bit-index. Returns true if the bit is set, false if not.</p>
<hr>
<h2 class="binding">buffer&#47;bit-clear</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;bit-clear buffer index)<br><br>Clears the bit at the given bit-index. Returns the buffer.</p>
<hr>
<h2 class="binding">buffer&#47;bit-set</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;bit-set buffer index)<br><br>Sets the bit at the given bit-index. Returns the buffer.</p>
<hr>
<h2 class="binding">buffer&#47;bit-toggle</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;bit-toggle buffer index)<br><br>Toggles the bit at the given bit index in buffer. Returns the buffer.</p>
<hr>
<h2 class="binding">buffer&#47;blit</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;blit dest src [, dest-start=0 [, src-start=0 [, src-end=-1]]])<br><br>Insert the contents of src into dest. Can optionally take indices that indicate which part of src to copy into which part of dest. Indices can be negative to index from the end of src or dest. Returns dest.</p>
<hr>
<h2 class="binding">buffer&#47;clear</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;clear buffer)<br><br>Sets the size of a buffer to 0 and empties it. The buffer retains its memory so it can be efficiently refilled. Returns the modified buffer.</p>
<hr>
<h2 class="binding">buffer&#47;new</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;new capacity)<br><br>Creates a new, empty buffer with enough memory for capacity bytes. Returns a new buffer.</p>
<hr>
<h2 class="binding">buffer&#47;new-filled</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;new-filled count [, byte=0])<br><br>Creates a new buffer of length count filled with byte. Returns the new buffer.</p>
<hr>
<h2 class="binding">buffer&#47;popn</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;popn buffer n)<br><br>Removes the last n bytes from the buffer. Returns the modified buffer.</p>
<hr>
<h2 class="binding">buffer&#47;push-byte</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;push-byte buffer x)<br><br>Append a byte to a buffer. Will expand the buffer as necessary. Returns the modified buffer. Will throw an error if the buffer overflows.</p>
<hr>
<h2 class="binding">buffer&#47;push-string</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;push-string buffer str)<br><br>Push a string onto the end of a buffer. Non string values will be converted to strings before being pushed. Returns the modified buffer. Will throw an error if the buffer overflows.</p>
<hr>
<h2 class="binding">buffer&#47;push-word</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;push-word buffer x)<br><br>Append a machine word to a buffer. The 4 bytes of the integer are appended in twos complement, big endian order, unsigned. Returns the modified buffer. Will throw an error if the buffer overflows.</p>
<hr>
<h2 class="binding">buffer&#47;slice</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(buffer&#47;slice bytes [, start=0 [, end=(length bytes)]])<br><br>Takes a slice of a byte sequence from start to end. The range is half open, [start, end). Indexes can also be negative, indicating indexing from the end of the end of the array. By default, start is 0 and end is the length of the buffer. Returns a new buffer.</p>
<hr>
<h2 class="binding">buffer?</h2>
<span class="binding-type">function</span>
<p class="docstring">(buffer? x)<br><br>Check if x is a buffer.</p>
<span class="source-map">core.janet (2538:2602)</span><hr>
<h2 class="binding">bxor</h2>
<span class="binding-type">function</span>
<p class="docstring">(bxor &amp; xs)<br><br>Returns the bit-wise xor of all values in xs. Each in xs must be an integer.</p>
<hr>
<h2 class="binding">bytes?</h2>
<span class="binding-type">function</span>
<p class="docstring">(bytes? x)<br><br>Check if x is a string, symbol, or buffer.</p>
<span class="source-map">core.janet (3088:3257)</span><hr>
<h2 class="binding">callable?</h2>
<span class="binding-type">function</span>
<p class="docstring">(callable? x)<br><br>Check if x is a function or cfunction.</p>
<span class="source-map">core.janet (3484:3608)</span><hr>
<h2 class="binding">case</h2>
<span class="binding-type">macro</span>
<p class="docstring">(case dispatch &amp; pairs)<br><br>Select the body that equals the dispatch value. When pairs  has an odd number of arguments, the last is the default expression.  If no match is found, returns nil</p>
<span class="source-map">core.janet (6504:7111)</span><hr>
<h2 class="binding">cfunction?</h2>
<span class="binding-type">function</span>
<p class="docstring">(cfunction? x)<br><br>Check if x a cfunction.</p>
<span class="source-map">core.janet (2696:2766)</span><hr>
<h2 class="binding">comment</h2>
<span class="binding-type">macro</span>
<p class="docstring">(comment)<br><br>Ignores the body of the comment.</p>
<span class="source-map">core.janet (5561:5620)</span><hr>
<h2 class="binding">comp</h2>
<span class="binding-type">function</span>
<p class="docstring">(comp &amp; functions)<br><br>Takes multiple functions and returns a function that is the composition  of those functions.</p>
<span class="source-map">core.janet (19020:19504)</span><hr>
<h2 class="binding">compile</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(compile ast env [, source])<br><br>Compiles an Abstract Syntax Tree (ast) into a janet function. Pair the compile function with parsing functionality to implement eval. Returns a janet function and does not modify ast. Throws an error if the ast cannot be compiled.</p>
<hr>
<h2 class="binding">complement</h2>
<span class="binding-type">function</span>
<p class="docstring">(complement f)<br><br>Returns a function that is the complement to the argument.</p>
<span class="source-map">core.janet (19582:19690)</span><hr>
<h2 class="binding">cond</h2>
<span class="binding-type">macro</span>
<p class="docstring">(cond &amp; pairs)<br><br>Evaluates conditions sequentially until the first true condition  is found, and then executes the corresponding body. If there are an  odd number of forms, the last expression is executed if no forms  are matched. If there are no matches, return nil.</p>
<span class="source-map">core.janet (5987:6501)</span><hr>
<h2 class="binding">coro</h2>
<span class="binding-type">macro</span>
<p class="docstring">(coro &amp; body)<br><br>A wrapper for making fibers. Same as (fiber&#47;new (fn [&amp;] ...body)).</p>
<span class="source-map">core.janet (17479:17618)</span><hr>
<h2 class="binding">count</h2>
<span class="binding-type">function</span>
<p class="docstring">(count pred ind)<br><br>Count the number of items in ind for which (pred item)  is true.</p>
<span class="source-map">core.janet (23372:23558)</span><hr>
<h2 class="binding">debug</h2>
<span class="binding-type">function</span>
<p class="docstring">(debug)<br><br>Throws a debug signal that can be caught by a parent fiber and used to inspect the running state of the current fiber. Returns nil.</p>
<hr>
<h2 class="binding">debug&#47;arg-stack</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;arg-stack fiber)<br><br>Gets all values currently on the fiber&#39;s argument stack. Normally, this should be empty unless the fiber signals while pushing arguments to make a function call. Returns a new array.</p>
<hr>
<h2 class="binding">debug&#47;break</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;break source byte-offset)<br><br>Sets a breakpoint with source a key at a given byte offset. An offset of 0 is the first byte in a file. Will throw an error if the breakpoint location cannot be found. For example<br><br>&nbsp;&nbsp;&nbsp;&nbsp;(debug&#47;break &quot;core.janet&quot; 1000)<br><br>wil set a breakpoint at the 1000th byte of the file core.janet.</p>
<hr>
<h2 class="binding">debug&#47;fbreak</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;fbreak fun [,pc=0])<br><br>Set a breakpoint in a given function. pc is an optional offset, which is in bytecode instructions. fun is a function value. Will throw an error if the offset is too large or negative.</p>
<hr>
<h2 class="binding">debug&#47;lineage</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;lineage fib)<br><br>Returns an array of all child fibers from a root fiber. This function is useful when a fiber signals or errors to an ancestor fiber. Using this function, the fiber handling the error can see which fiber raised the signal. This function should be used mostly for debugging purposes.</p>
<hr>
<h2 class="binding">debug&#47;stack</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;stack fib)<br><br>Gets information about the stack as an array of tables. Each table in the array contains information about a stack frame. The top most, current stack frame is the first table in the array, and the bottom most stack frame is the last value. Each stack frame contains some of the following attributes:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:c - true if the stack frame is a c function invocation<br>&nbsp;&nbsp;&nbsp;&nbsp;:column - the current source column of the stack frame<br>&nbsp;&nbsp;&nbsp;&nbsp;:function - the function that the stack frame represents<br>&nbsp;&nbsp;&nbsp;&nbsp;:line - the current source line of the stack frame<br>&nbsp;&nbsp;&nbsp;&nbsp;:name - the human friendly name of the function<br>&nbsp;&nbsp;&nbsp;&nbsp;:pc - integer indicating the location of the program counter<br>&nbsp;&nbsp;&nbsp;&nbsp;:source - string with the file path or other identifier for the source code<br>&nbsp;&nbsp;&nbsp;&nbsp;:slots - array of all values in each slot<br>&nbsp;&nbsp;&nbsp;&nbsp;:tail - boolean indicating a tail call</p>
<hr>
<h2 class="binding">debug&#47;unbreak</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;unbreak source byte-offset)<br><br>Remove a breakpoint with a source key at a given byte offset. An offset of 0 is the first byte in a file. Will throw an error if the breakpoint cannot be found.</p>
<hr>
<h2 class="binding">debug&#47;unfbreak</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(debug&#47;unfbreak fun [,pc=0])<br><br>Unset a breakpoint set with debug&#47;fbreak.</p>
<hr>
<h2 class="binding">dec</h2>
<span class="binding-type">function</span>
<p class="docstring">(dec x)<br><br>Returns x - 1.</p>
<span class="source-map">core.janet (4847:4885)</span><hr>
<h2 class="binding">deep-not=</h2>
<span class="binding-type">function</span>
<p class="docstring">(deep-not= x y)<br><br>Like not=, but mutable types (arrays, tables, buffers) are considered  equal if they have identical structure. Much slower than not=.</p>
<span class="source-map">core.janet (41389:41952)</span><hr>
<h2 class="binding">deep=</h2>
<span class="binding-type">function</span>
<p class="docstring">(deep= x y)<br><br>Like =, but mutable types (arrays, tables, buffers) are considered  equal if they have identical structure. Much slower than =.</p>
<span class="source-map">core.janet (41955:42131)</span><hr>
<h2 class="binding">def-</h2>
<span class="binding-type">macro</span>
<p class="docstring">(def- name &amp; more)<br><br>Define a private value that will not be exported.</p>
<span class="source-map">core.janet (1474:1589)</span><hr>
<h2 class="binding">default</h2>
<span class="binding-type">macro</span>
<p class="docstring">(default sym val)<br><br>Define a default value for an optional argument.  Expands to (def sym (if (= nil sym) val sym))</p>
<span class="source-map">core.janet (5386:5558)</span><hr>
<h2 class="binding">defglobal</h2>
<span class="binding-type">function</span>
<p class="docstring">(defglobal name value)<br><br>Dynamically create a global def.</p>
<span class="source-map">core.janet (1592:1729)</span><hr>
<h2 class="binding">defmacro</h2>
<span class="binding-type">macro</span>
<p class="docstring">(defmacro name &amp; more)<br><br>Define a macro.</p>
<span class="source-map">core.janet (1124:1213)</span><hr>
<h2 class="binding">defmacro-</h2>
<span class="binding-type">macro</span>
<p class="docstring">(defmacro- name &amp; more)<br><br>Define a private macro that will not be exported.</p>
<span class="source-map">core.janet (1216:1346)</span><hr>
<h2 class="binding">defn</h2>
<span class="binding-type">macro</span>
<p class="docstring">(def name &amp; more)<br><br>Define a function. Equivalent to (def name (fn name [args] ...)).</p>
<span class="source-map">core.janet (157:1121)</span><hr>
<h2 class="binding">defn-</h2>
<span class="binding-type">macro</span>
<p class="docstring">(defn- name &amp; more)<br><br>Define a private function that will not be exported.</p>
<span class="source-map">core.janet (1349:1471)</span><hr>
<h2 class="binding">describe</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(describe x)<br><br>Returns a string that is a human readable description of a value x.</p>
<hr>
<h2 class="binding">dictionary?</h2>
<span class="binding-type">function</span>
<p class="docstring">(dictionary? x)<br><br>Check if x a table or struct.</p>
<span class="source-map">core.janet (3259:3370)</span><hr>
<h2 class="binding">disasm</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(disasm func)<br><br>Returns assembly that could be used be compile the given function.<br>func must be a function, not a c function. Will throw on error on a badly<br>typed argument.</p>
<hr>
<h2 class="binding">distinct</h2>
<span class="binding-type">function</span>
<p class="docstring">(distinct xs)<br><br>Returns an array of the deduplicated values in xs.</p>
<span class="source-map">core.janet (33380:33579)</span><hr>
<h2 class="binding">doc</h2>
<span class="binding-type">macro</span>
<p class="docstring">(doc sym)<br><br>Shows documentation for the given symbol.</p>
<span class="source-map">core.janet (38669:38776)</span><hr>
<h2 class="binding">doc*</h2>
<span class="binding-type">function</span>
<p class="docstring">(doc* env sym)<br><br>Get the documentation for a symbol in a given environment.</p>
<span class="source-map">core.janet (37939:38666)</span><hr>
<h2 class="binding">doc-format</h2>
<span class="binding-type">function</span>
<p class="docstring">(doc-format text)<br><br>Reformat text to wrap at a given line.</p>
<span class="source-map">core.janet (37089:37936)</span><hr>
<h2 class="binding">drop-until</h2>
<span class="binding-type">function</span>
<p class="docstring">(drop-until pred ind)<br><br>Given a predicate, remove elements from an indexed type that satisfy  the predicate, and abort on first failure. Returns a new tuple.</p>
<span class="source-map">core.janet (25501:25723)</span><hr>
<h2 class="binding">drop-while</h2>
<span class="binding-type">function</span>
<p class="docstring">(drop-while pred ind)<br><br>Same as (drop-until (complement pred) ind).</p>
<span class="source-map">core.janet (25726:25840)</span><hr>
<h2 class="binding">each</h2>
<span class="binding-type">macro</span>
<p class="docstring">(each binding ind &amp; body)<br><br>Loop over each value in ind. Returns nil.</p>
<span class="source-map">core.janet (17349:17476)</span><hr>
<h2 class="binding">empty?</h2>
<span class="binding-type">function</span>
<p class="docstring">(empty? xs)<br><br>Check if xs is empty.</p>
<span class="source-map">core.janet (3760:3819)</span><hr>
<h2 class="binding">env-lookup</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(env-lookup env)<br><br>Creates a forward lookup table for unmarshalling from an environment. To create a reverse lookup table, use the invert function to swap keys and values in the returned table.</p>
<hr>
<h2 class="binding">error</h2>
<span class="binding-type">function</span>
<p class="docstring">(error e)<br><br>Throws an error e that can be caught and handled by a parent fiber.</p>
<hr>
<h2 class="binding">eval</h2>
<span class="binding-type">function</span>
<p class="docstring">(eval form)<br><br>Evaluates a form in the current environment. If more control over the  environment is needed, use run-context.</p>
<span class="source-map">core.janet (46799:47041)</span><hr>
<h2 class="binding">eval-string</h2>
<span class="binding-type">function</span>
<p class="docstring">(eval-string str)<br><br>Evaluates a string in the current environment. If more control over the  environment is needed, use run-context.</p>
<span class="source-map">core.janet (46235:46796)</span><hr>
<h2 class="binding">even?</h2>
<span class="binding-type">function</span>
<p class="docstring">(even? x)<br><br>Check if x is even.</p>
<span class="source-map">core.janet (1890:1942)</span><hr>
<h2 class="binding">every?</h2>
<span class="binding-type">function</span>
<p class="docstring">(every? ind)<br><br>Returns true if each value in is truthy, otherwise the first  falsey value.</p>
<span class="source-map">core.janet (30374:30557)</span><hr>
<h2 class="binding">extreme</h2>
<span class="binding-type">function</span>
<p class="docstring">(extreme order args)<br><br>Returns the most extreme value in args based on the function order.  order should take two values and return true or false (a comparison).  Returns nil if args is empty.</p>
<span class="source-map">core.janet (19693:20066)</span><hr>
<h2 class="binding">false?</h2>
<span class="binding-type">function</span>
<p class="docstring">(false? x)<br><br>Check if x is false.</p>
<span class="source-map">core.janet (3660:3711)</span><hr>
<h2 class="binding">fiber&#47;current</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(fiber&#47;current)<br><br>Returns the currently running fiber.</p>
<hr>
<h2 class="binding">fiber&#47;maxstack</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(fiber&#47;maxstack fib)<br><br>Gets the maximum stack size in janet values allowed for a fiber. While memory for the fiber&#39;s stack is not allocated up front, the fiber will not allocated more than this amount and will throw a stack-overflow error if more memory is needed. </p>
<hr>
<h2 class="binding">fiber&#47;new</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(fiber&#47;new func [,sigmask])<br><br>Create a new fiber with function body func. Can optionally take a set of signals to block from the current parent fiber when called. The mask is specified as a keyword where each character is used to indicate a signal to block. The default sigmask is :y. For example, <br><br>&nbsp;&nbsp;&nbsp;&nbsp;(fiber&#47;new myfun :e123)<br><br>blocks error signals and user signals 1, 2 and 3. The signals are as follows: <br><br>&nbsp;&nbsp;&nbsp;&nbsp;a - block all signals<br>&nbsp;&nbsp;&nbsp;&nbsp;d - block debug signals<br>&nbsp;&nbsp;&nbsp;&nbsp;e - block error signals<br>&nbsp;&nbsp;&nbsp;&nbsp;u - block user signals<br>&nbsp;&nbsp;&nbsp;&nbsp;y - block yield signals<br>&nbsp;&nbsp;&nbsp;&nbsp;0-9 - block a specific user signal</p>
<hr>
<h2 class="binding">fiber&#47;setmaxstack</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(fiber&#47;setmaxstack fib maxstack)<br><br>Sets the maximum stack size in janet values for a fiber. By default, the maximum stack size is usually 8192.</p>
<hr>
<h2 class="binding">fiber&#47;status</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(fiber&#47;status fib)<br><br>Get the status of a fiber. The status will be one of:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:dead - the fiber has finished<br>&nbsp;&nbsp;&nbsp;&nbsp;:error - the fiber has errored out<br>&nbsp;&nbsp;&nbsp;&nbsp;:debug - the fiber is suspended in debug mode<br>&nbsp;&nbsp;&nbsp;&nbsp;:pending - the fiber has been yielded<br>&nbsp;&nbsp;&nbsp;&nbsp;:user(0-9) - the fiber is suspended by a user signal<br>&nbsp;&nbsp;&nbsp;&nbsp;:alive - the fiber is currently running and cannot be resumed<br>&nbsp;&nbsp;&nbsp;&nbsp;:new - the fiber has just been created and not yet run</p>
<hr>
<h2 class="binding">fiber?</h2>
<span class="binding-type">function</span>
<p class="docstring">(fiber? x)<br><br>Check if x is a fiber.</p>
<span class="source-map">core.janet (2274:2335)</span><hr>
<h2 class="binding">file&#47;close</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;close f)<br><br>Close a file and release all related resources. When you are done reading a file, close it to prevent a resource leak and let other processes read the file.</p>
<hr>
<h2 class="binding">file&#47;flush</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;flush f)<br><br>Flush any buffered bytes to the file system. In most files, writes are buffered for efficiency reasons. Returns the file handle.</p>
<hr>
<h2 class="binding">file&#47;open</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;open path [,mode])<br><br>Open a file. path is an absolute or relative path, and mode is a set of flags indicating the mode to open the file in. mode is a keyword where each character represents a flag. If the file cannot be opened, returns nil, otherwise returns the new file handle. Mode flags:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;r - allow reading from the file<br>&nbsp;&nbsp;&nbsp;&nbsp;w - allow writing to the file<br>&nbsp;&nbsp;&nbsp;&nbsp;a - append to the file<br>&nbsp;&nbsp;&nbsp;&nbsp;b - open the file in binary mode (rather than text mode)<br>&nbsp;&nbsp;&nbsp;&nbsp;+ - append to the file instead of overwriting it</p>
<hr>
<h2 class="binding">file&#47;popen</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;popen path [,mode])<br><br>Open a file that is backed by a process. The file must be opened in either the :r (read) or the :w (write) mode. In :r mode, the stdout of the process can be read from the file. In :w mode, the stdin of the process can be written to. Returns the new file.</p>
<hr>
<h2 class="binding">file&#47;read</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;read f what [,buf])<br><br>Read a number of bytes from a file into a buffer. A buffer can be provided as an optional fourth argument, otherwise a new buffer is created. &#39;what&#39; can either be an integer or a keyword. Returns the buffer with file contents. Values for &#39;what&#39;:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:all - read the whole file<br>&nbsp;&nbsp;&nbsp;&nbsp;:line - read up to and including the next newline character<br>&nbsp;&nbsp;&nbsp;&nbsp;n (integer) - read up to n bytes from the file</p>
<hr>
<h2 class="binding">file&#47;seek</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;seek f [,whence [,n]])<br><br>Jump to a relative location in the file. &#39;whence&#39; must be one of<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:cur - jump relative to the current file location<br>&nbsp;&nbsp;&nbsp;&nbsp;:set - jump relative to the beginning of the file<br>&nbsp;&nbsp;&nbsp;&nbsp;:end - jump relative to the end of the file<br><br>By default, &#39;whence&#39; is :cur. Optionally a value n may be passed for the relative number of bytes to seek in the file. n may be a real number to handle large files of more the 4GB. Returns the file handle.</p>
<hr>
<h2 class="binding">file&#47;write</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(file&#47;write f bytes)<br><br>Writes to a file. &#39;bytes&#39; must be string, buffer, or symbol. Returns the file.</p>
<hr>
<h2 class="binding">filter</h2>
<span class="binding-type">function</span>
<p class="docstring">(filter pred ind)<br><br>Given a predicate, take only elements from an array or tuple for  which (pred element) is truthy. Returns a new array.</p>
<span class="source-map">core.janet (23125:23369)</span><hr>
<h2 class="binding">find</h2>
<span class="binding-type">function</span>
<p class="docstring">(find pred ind)<br><br>Find the first value in an indexed collection that satisfies a predicate. Returns  nil if not found. Note their is no way to differentiate a nil from the indexed collection  and a not found. Consider find-index if this is an issue.</p>
<span class="source-map">core.janet (24837:25132)</span><hr>
<h2 class="binding">find-index</h2>
<span class="binding-type">function</span>
<p class="docstring">(find-index pred ind)<br><br>Find the index of indexed type for which pred is true. Returns nil if not found.</p>
<span class="source-map">core.janet (24541:24834)</span><hr>
<h2 class="binding">first</h2>
<span class="binding-type">function</span>
<p class="docstring">(first xs)<br><br>Get the first element from an indexed data structure.</p>
<span class="source-map">core.janet (20525:20614)</span><hr>
<h2 class="binding">flatten</h2>
<span class="binding-type">function</span>
<p class="docstring">(flatten xs)<br><br>Takes a nested array (tree), and returns the depth first traversal of  that array. Returns a new array.</p>
<span class="source-map">core.janet (33845:33998)</span><hr>
<h2 class="binding">flatten-into</h2>
<span class="binding-type">function</span>
<p class="docstring">(flatten-into into xs)<br><br>Takes a nested array (tree), and appends the depth first traversal of  that array to an array &#39;into&#39;. Returns array into.</p>
<span class="source-map">core.janet (33582:33842)</span><hr>
<h2 class="binding">for</h2>
<span class="binding-type">macro</span>
<p class="docstring">(for binding start end &amp; body)<br><br>Do a c style for loop for side effects. Returns nil.</p>
<span class="source-map">core.janet (17186:17346)</span><hr>
<h2 class="binding">frequencies</h2>
<span class="binding-type">function</span>
<p class="docstring">(frequencies ind)<br><br>Get the number of occurrences of each value in a indexed structure.</p>
<span class="source-map">core.janet (32841:33052)</span><hr>
<h2 class="binding">function?</h2>
<span class="binding-type">function</span>
<p class="docstring">(function? x)<br><br>Check if x is a function (not a cfunction).</p>
<span class="source-map">core.janet (2604:2694)</span><hr>
<h2 class="binding">gccollect</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(gccollect)<br><br>Run garbage collection. You should probably not call this manually.</p>
<hr>
<h2 class="binding">gcinterval</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(gcinterval)<br><br>Returns the integer number of bytes to allocate before running an iteration of garbage collection.</p>
<hr>
<h2 class="binding">gcsetinterval</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(gcsetinterval interval)<br><br>Set an integer number of bytes to allocate before running garbage collection. Low valuesi for interval will be slower but use less memory. High values will be faster but use more memory.</p>
<hr>
<h2 class="binding">generate</h2>
<span class="binding-type">macro</span>
<p class="docstring">(generate head &amp; body)<br><br>Create a generator expression using the loop syntax. Returns a fiber  that yields all values inside the loop in order. See loop for details.</p>
<span class="source-map">core.janet (16946:17183)</span><hr>
<h2 class="binding">gensym</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(gensym)<br><br>Returns a new symbol that is unique across the runtime. This means it will not collide with any already created symbols during compilation, so it can be used in macros to generate automatic bindings.</p>
<hr>
<h2 class="binding">get</h2>
<span class="binding-type">function</span>
<p class="docstring">(get ds key)<br><br>Get a value from any associative data structure. Arrays, tuples, tables, structs, strings, symbols, and buffers are all associative and can be used with get. Order structures, name arrays, tuples, strings, buffers, and symbols must use integer keys. Structs and tables can take any value as a key except nil and return a value except nil. Byte sequences will return integer representations of bytes as result of a get call.</p>
<hr>
<h2 class="binding">hash</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(hash value)<br><br>Gets a hash value for any janet value. The hash is an integer can be used as a cheap hash function for all janet objects. If two values are strictly equal, then they will have the same hash value.</p>
<hr>
<h2 class="binding">idempotent?</h2>
<span class="binding-type">function</span>
<p class="docstring">(idempotent? x)<br><br>Check if x is a value that evaluates to itself when compiled.</p>
<span class="source-map">core.janet (3821:4117)</span><hr>
<h2 class="binding">identity</h2>
<span class="binding-type">function</span>
<p class="docstring">(identity x)<br><br>A function that returns its first argument.</p>
<span class="source-map">core.janet (19507:19579)</span><hr>
<h2 class="binding">if-let</h2>
<span class="binding-type">macro</span>
<p class="docstring">(if-let bindings tru fal &amp;)<br><br>Make multiple bindings, and if all are truthy,  evaluate the tru form. If any are false or nil, evaluate  the fal form. Bindings have the same syntax as the let macro.</p>
<span class="source-map">core.janet (17889:18900)</span><hr>
<h2 class="binding">if-not</h2>
<span class="binding-type">macro</span>
<p class="docstring">(if-not condition exp-1 exp-2 &amp;)<br><br>Shorthand for (if (not ... </p>
<span class="source-map">core.janet (5623:5732)</span><hr>
<h2 class="binding">import</h2>
<span class="binding-type">macro</span>
<p class="docstring">(import path &amp; args)<br><br>Import a module. First requires the module, and then merges its  symbols into the current environment, prepending a given prefix as needed.  (use the :as or :prefix option to set a prefix). If no prefix is provided,  use the name of the module as a prefix.</p>
<span class="source-map">core.janet (50605:51087)</span><hr>
<h2 class="binding">import*</h2>
<span class="binding-type">function</span>
<p class="docstring">(import* env path &amp; args)<br><br>Import a module into a given environment table. This is the  functional form of (import ...) that expects and explicit environment  table.</p>
<span class="source-map">core.janet (50120:50602)</span><hr>
<h2 class="binding">inc</h2>
<span class="binding-type">function</span>
<p class="docstring">(inc x)<br><br>Returns x + 1.</p>
<span class="source-map">core.janet (4807:4845)</span><hr>
<h2 class="binding">indexed?</h2>
<span class="binding-type">function</span>
<p class="docstring">(indexed? x)<br><br>Check if x is an array or tuple.</p>
<span class="source-map">core.janet (3372:3482)</span><hr>
<h2 class="binding">interleave</h2>
<span class="binding-type">function</span>
<p class="docstring">(interleave &amp; cols)<br><br>Returns an array of the first elements of each col,  then the second, etc.</p>
<span class="source-map">core.janet (33055:33377)</span><hr>
<h2 class="binding">interpose</h2>
<span class="binding-type">function</span>
<p class="docstring">(interpose sep ind)<br><br>Returns a sequence of the elements of ind separated by  sep. Returns a new array.</p>
<span class="source-map">core.janet (34241:34547)</span><hr>
<h2 class="binding">invert</h2>
<span class="binding-type">function</span>
<p class="docstring">(invert ds)<br><br>Returns a table of where the keys of an associative data structureare the values, and the values of the keys. If multiple keys have the samevalue, one key will be ignored.</p>
<span class="source-map">core.janet (30825:31093)</span><hr>
<h2 class="binding">janet&#47;build</h2>
<span class="binding-type">string</span>
<p class="docstring">The build identifier of the running janet program.</p>
<hr>
<h2 class="binding">janet&#47;version</h2>
<span class="binding-type">string</span>
<p class="docstring">The version number of the running janet program.</p>
<hr>
<h2 class="binding">juxt</h2>
<span class="binding-type">macro</span>
<p class="docstring">(juxt &amp; funs)<br><br>Macro form of juxt*. Same behavior but more efficient.</p>
<span class="source-map">core.janet (26097:26348)</span><hr>
<h2 class="binding">juxt*</h2>
<span class="binding-type">function</span>
<p class="docstring">(juxt* &amp; funs)<br><br>Returns the juxtaposition of functions. In other words,  ((juxt* a b c) x) evaluates to ((a x) (b x) (c x)).</p>
<span class="source-map">core.janet (25843:26094)</span><hr>
<h2 class="binding">keep</h2>
<span class="binding-type">function</span>
<p class="docstring">(keep pred ind)<br><br>Given a predicate, take only elements from an array or tuple for  which (pred element) is truthy. Returns a new array of truthy predicate results.</p>
<span class="source-map">core.janet (23561:23836)</span><hr>
<h2 class="binding">keys</h2>
<span class="binding-type">function</span>
<p class="docstring">(keys x)<br><br>Get the keys of an associative data structure.</p>
<span class="source-map">core.janet (32199:32399)</span><hr>
<h2 class="binding">keyword</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(keyword &amp; xs)<br><br>Creates a keyword by concatenating values together. Values are converted to bytes via describe if they are not byte sequences. Returns the new keyword.</p>
<hr>
<h2 class="binding">keyword?</h2>
<span class="binding-type">function</span>
<p class="docstring">(keyword? x)<br><br>Check if x is a keyword.</p>
<span class="source-map">core.janet (2469:2536)</span><hr>
<h2 class="binding">kvs</h2>
<span class="binding-type">function</span>
<p class="docstring">(kvs dict)<br><br>Takes a table or struct and returns and array of key value pairs  like @[k v k v ...]. Returns a new array.</p>
<span class="source-map">core.janet (34001:34238)</span><hr>
<h2 class="binding">last</h2>
<span class="binding-type">function</span>
<p class="docstring">(last xs)<br><br>Get the last element from an indexed data structure.</p>
<span class="source-map">core.janet (20617:20720)</span><hr>
<h2 class="binding">length</h2>
<span class="binding-type">function</span>
<p class="docstring">(length ds)<br><br>Returns the length or count of a data structure in constant time as an integer. For structs and tables, returns the number of key-value pairs in the data structure.</p>
<hr>
<h2 class="binding">let</h2>
<span class="binding-type">macro</span>
<p class="docstring">(let bindings &amp; body)<br><br>Create a scope and bind values to symbols. Each pair in bindings is  assigned as if with def, and the body of the let form returns the last  value.</p>
<span class="source-map">core.janet (7114:7606)</span><hr>
<h2 class="binding">loop</h2>
<span class="binding-type">macro</span>
<p class="docstring">(loop head &amp; body)<br><br>A general purpose loop macro. This macro is similar to the Common Lisp  loop macro, although intentionally much smaller in scope.  The head of the loop should be a tuple that contains a sequence of  either bindings or conditionals. A binding is a sequence of three values  that define something to loop over. They are formatted like:<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;binding :verb object&#47;expression<br><br>  Where binding is a binding as passed to def, :verb is one of a set of keywords,  and object is any janet expression. The available verbs are:<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;:iterate - repeatedly evaluate and bind to the expression while it is truthy.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:range - loop over a range. The object should be two element tuple with a start  and end value. The range is half open, [start, end).<br>  &nbsp;&nbsp;&nbsp;&nbsp;:keys - Iterate over the keys in a data structure.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:pairs - Iterate over the keys value pairs in a data structure.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:in - Iterate over the values in an indexed data structure or byte sequence.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:generate - Iterate over values yielded from a fiber. Can be paired with the generator  function for the producer&#47;consumer pattern.<br><br>  loop also accepts conditionals to refine the looping further. Conditionals are of  the form:<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;:modifier argument<br><br>  where :modifier is one of a set of keywords, and argument is keyword dependent.  :modifier can be one of:<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;:while expression - breaks from the loop if expression is falsey.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:let bindings - defines bindings inside the loop as passed to the let macro.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:before form - evaluates a form for a side effect before of the next inner loop.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:after form - same as :before, but the side effect happens after the next inner loop.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:repeat n - repeats the next inner loop n times.<br>  &nbsp;&nbsp;&nbsp;&nbsp;:when condition - only evaluates the loop body when condition is true.<br><br>  The loop macro always evaluates to nil.</p>
<span class="source-map">core.janet (8974:16700)</span><hr>
<h2 class="binding">macex</h2>
<span class="binding-type">function</span>
<p class="docstring">(macex x)<br><br>Expand macros completely.</p>
<span class="source-map">core.janet (42134:42429)</span><hr>
<h2 class="binding">macex1</h2>
<span class="binding-type">function</span>
<p class="docstring">(macex1 x)<br><br>Expand macros in a form, but do not recursively expand macros.</p>
<span class="source-map">core.janet (38816:41006)</span><hr>
<h2 class="binding">make-env</h2>
<span class="binding-type">function</span>
<p class="docstring">(make-env parent &amp;)<br><br>Create a new environment table. The new environment  will inherit bindings from the parent environment, but new  bindings will not pollute the parent environment.</p>
<span class="source-map">core.janet (42553:42966)</span><hr>
<h2 class="binding">map</h2>
<span class="binding-type">function</span>
<p class="docstring">(map f &amp; inds)<br><br>Map a function over every element in an indexed data structure and  return an array of the results.</p>
<span class="source-map">core.janet (21822:22743)</span><hr>
<h2 class="binding">mapcat</h2>
<span class="binding-type">function</span>
<p class="docstring">(mapcat f ind)<br><br>Map a function over every element in an array or tuple and  use array to concatenate the results.</p>
<span class="source-map">core.janet (22746:22943)</span><hr>
<h2 class="binding">marshal</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(marshal x [,reverse-lookup [,buffer]])<br><br>Marshal a janet value into a buffer and return the buffer. The buffer can the later be unmarshalled to reconstruct the initial value. Optionally, one can pass in a reverse lookup table to not marshal aliased values that are found in the table. Then a forwardlookup table can be used to recover the original janet value when unmarshalling.</p>
<hr>
<h2 class="binding">match</h2>
<span class="binding-type">macro</span>
<p class="docstring">(match x &amp; cases)<br><br>Pattern matching. Match an expression x against  any number of cases. Easy case is a pattern to match against, followed  by an expression to evaluate to if that case is matched. A pattern that is  a symbol will match anything, binding x&#39;s value to that symbol. An array  will match only if all of it&#39;s elements match the corresponding elements in  x. A table or struct will match if all values match with the corresponding  values in x. A tuple pattern will match if it&#39;s first element matches, and the following  elements are treated as predicates and are true. Any other value pattern will only  match if it is equal to x.</p>
<span class="source-map">core.janet (35853:36934)</span><hr>
<h2 class="binding">math&#47;acos</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;acos x)<br><br>Returns the arccosine of x.</p>
<hr>
<h2 class="binding">math&#47;asin</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;asin x)<br><br>Returns the arcsine of x.</p>
<hr>
<h2 class="binding">math&#47;atan</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;atan x)<br><br>Returns the arctangent of x.</p>
<hr>
<h2 class="binding">math&#47;ceil</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;ceil x)<br><br>Returns the smallest integer value number that is not less than x.</p>
<hr>
<h2 class="binding">math&#47;cos</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;cos x)<br><br>Returns the cosine of x.</p>
<hr>
<h2 class="binding">math&#47;e</h2>
<span class="binding-type">number</span>
<p class="docstring">The base of the natural log.</p>
<hr>
<h2 class="binding">math&#47;exp</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;exp x)<br><br>Returns e to the power of x.</p>
<hr>
<h2 class="binding">math&#47;floor</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;floor x)<br><br>Returns the largest integer value number that is not greater than x.</p>
<hr>
<h2 class="binding">math&#47;inf</h2>
<span class="binding-type">number</span>
<p class="docstring">The number representing positive infinity</p>
<hr>
<h2 class="binding">math&#47;log</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;log x)<br><br>Returns log base 2 of x.</p>
<hr>
<h2 class="binding">math&#47;log10</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;log10 x)<br><br>Returns log base 10 of x.</p>
<hr>
<h2 class="binding">math&#47;pi</h2>
<span class="binding-type">number</span>
<p class="docstring">The value pi.</p>
<hr>
<h2 class="binding">math&#47;pow</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;pow a x)<br><br>Return a to the power of x.</p>
<hr>
<h2 class="binding">math&#47;random</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;random)<br><br>Returns a uniformly distributed random number between 0 and 1.</p>
<hr>
<h2 class="binding">math&#47;seedrandom</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;seedrandom seed)<br><br>Set the seed for the random number generator. &#39;seed&#39; should be an an integer.</p>
<hr>
<h2 class="binding">math&#47;sin</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;sin x)<br><br>Returns the sine of x.</p>
<hr>
<h2 class="binding">math&#47;sqrt</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;sqrt x)<br><br>Returns the square root of x.</p>
<hr>
<h2 class="binding">math&#47;tan</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(math&#47;tan x)<br><br>Returns the tangent of x.</p>
<hr>
<h2 class="binding">max</h2>
<span class="binding-type">function</span>
<p class="docstring">(max &amp; args)<br><br>Returns the numeric maximum of the arguments.</p>
<span class="source-map">core.janet (20069:20156)</span><hr>
<h2 class="binding">max-order</h2>
<span class="binding-type">function</span>
<p class="docstring">(max-order &amp; args)<br><br>Returns the maximum of the arguments according to a total  order over all values.</p>
<span class="source-map">core.janet (20249:20384)</span><hr>
<h2 class="binding">merge</h2>
<span class="binding-type">function</span>
<p class="docstring">(merge &amp; colls)<br><br>Merges multiple tables&#47;structs to one. If a key appears in more than one  collection, then later values replace any previous ones.  Returns a new table.</p>
<span class="source-map">core.janet (31898:32196)</span><hr>
<h2 class="binding">merge-into</h2>
<span class="binding-type">function</span>
<p class="docstring">(merge-into tab &amp; colls)<br><br>Merges multiple tables&#47;structs into a table. If a key appears in more than one  collection, then later values replace any previous ones.  Returns the original table.</p>
<span class="source-map">core.janet (31609:31895)</span><hr>
<h2 class="binding">meta</h2>
<span class="binding-type">macro</span>
<p class="docstring">(meta &amp; args)<br><br>Add metadata to the current environment.</p>
<span class="source-map">core.janet (51814:51960)</span><hr>
<h2 class="binding">min</h2>
<span class="binding-type">function</span>
<p class="docstring">(min &amp; args)<br><br>Returns the numeric minimum of the arguments.</p>
<span class="source-map">core.janet (20159:20246)</span><hr>
<h2 class="binding">min-order</h2>
<span class="binding-type">function</span>
<p class="docstring">(min-order &amp; args)<br><br>Returns the minimum of the arguments according to a total  order over all values.</p>
<span class="source-map">core.janet (20387:20522)</span><hr>
<h2 class="binding">module&#47;find</h2>
<span class="binding-type">function</span>
<p class="docstring">(module&#47;find path paths)<br><br>Try to match a module or path name from the patterns in paths.</p>
<span class="source-map">core.janet (47932:48268)</span><hr>
<h2 class="binding">native</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(native path [,env])<br><br>Load a native module from the given path. The path must be an absolute or relative path on the file system, and is usually a .so file on Unix systems, and a .dll file on Windows. Returns an environment table that contains functions and other values from the native module.</p>
<hr>
<h2 class="binding">neg?</h2>
<span class="binding-type">function</span>
<p class="docstring">(neg? x)<br><br>Check if x is less than 0.</p>
<span class="source-map">core.janet (2102:2153)</span><hr>
<h2 class="binding">next</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(next dict key)<br><br>Gets the next key in a struct or table. Can be used to iterate through the keys of a data structure in an unspecified order. Keys are guaranteed to be seen only once per iteration if they data structure is not mutated during iteration. If key is nil, next returns the first key. If next returns nil, there are no more keys to iterate through. </p>
<hr>
<h2 class="binding">nil?</h2>
<span class="binding-type">function</span>
<p class="docstring">(nil? x)<br><br>Check if x is nil.</p>
<span class="source-map">core.janet (3713:3758)</span><hr>
<h2 class="binding">not</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(not x)<br><br>Returns the boolean inverse of x.</p>
<hr>
<h2 class="binding">not=</h2>
<span class="binding-type">function</span>
<p class="docstring">(not= &amp; xs)<br><br>Return true if any values in xs are not equal, otherwise false.</p>
<hr>
<h2 class="binding">not==</h2>
<span class="binding-type">function</span>
<p class="docstring">(not== &amp; xs)<br><br>Check if any values in xs are not numerically equal (3.0 not== 4). Returns a boolean.</p>
<hr>
<h2 class="binding">number?</h2>
<span class="binding-type">function</span>
<p class="docstring">(number? x)<br><br>Check if x is a number.</p>
<span class="source-map">core.janet (2208:2272)</span><hr>
<h2 class="binding">odd?</h2>
<span class="binding-type">function</span>
<p class="docstring">(odd? x)<br><br>Check if x is odd.</p>
<span class="source-map">core.janet (1944:1996)</span><hr>
<h2 class="binding">one?</h2>
<span class="binding-type">function</span>
<p class="docstring">(one? x)<br><br>Check if x is equal to 1.</p>
<span class="source-map">core.janet (2155:2206)</span><hr>
<h2 class="binding">or</h2>
<span class="binding-type">macro</span>
<p class="docstring">(or &amp; forms)<br><br>Evaluates to the last argument if all preceding elements are false, otherwise  evaluates to true.</p>
<span class="source-map">core.janet (8544:8971)</span><hr>
<h2 class="binding">order&lt;</h2>
<span class="binding-type">function</span>
<p class="docstring">(order&lt; &amp; xs)<br><br>Check if xs is strictly increasing according to a total order over all values. Returns a boolean.</p>
<hr>
<h2 class="binding">order&lt;=</h2>
<span class="binding-type">function</span>
<p class="docstring">(order&lt;= &amp; xs)<br><br>Check if xs is not decreasing according to a total order over all values. Returns a boolean.</p>
<hr>
<h2 class="binding">order&gt;</h2>
<span class="binding-type">function</span>
<p class="docstring">(order&gt; &amp; xs)<br><br>Check if xs is strictly descending according to a total order over all values. Returns a boolean.</p>
<hr>
<h2 class="binding">order&gt;=</h2>
<span class="binding-type">function</span>
<p class="docstring">(order&gt;= &amp; xs)<br><br>Check if xs is not increasing according to a total order over all values. Returns a boolean.</p>
<hr>
<h2 class="binding">os&#47;clock</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;clock)<br><br>Return the number of seconds since some fixed point in time. The clock is guaranteed to be non decreased in real time.</p>
<hr>
<h2 class="binding">os&#47;cwd</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;cwd)<br><br>Returns the current working directory.</p>
<hr>
<h2 class="binding">os&#47;execute</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;execute program &amp; args)<br><br>Execute a program on the system and pass it string arguments. Returns the exit status of the program.</p>
<hr>
<h2 class="binding">os&#47;exit</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;exit x)<br><br>Exit from janet with an exit code equal to x. If x is not an integer, the exit with status equal the hash of x.</p>
<hr>
<h2 class="binding">os&#47;getenv</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;getenv variable)<br><br>Get the string value of an environment variable.</p>
<hr>
<h2 class="binding">os&#47;setenv</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;setenv variable value)<br><br>Set an environment variable.</p>
<hr>
<h2 class="binding">os&#47;shell</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;shell str)<br><br>Pass a command string str directly to the system shell.</p>
<hr>
<h2 class="binding">os&#47;sleep</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;sleep nsec)<br><br>Suspend the program for nsec seconds. &#39;nsec&#39; can be a real number. Returns nil.</p>
<hr>
<h2 class="binding">os&#47;time</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;time)<br><br>Get the current time expressed as the number of seconds since January 1, 1970, the Unix epoch. Returns a real number.</p>
<hr>
<h2 class="binding">os&#47;which</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(os&#47;which)<br><br>Check the current operating system. Returns one of:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:windows - Microsoft Windows<br>&nbsp;&nbsp;&nbsp;&nbsp;:macos - Apple macos<br>&nbsp;&nbsp;&nbsp;&nbsp;:posix - A POSIX compatible system (default)</p>
<hr>
<h2 class="binding">pairs</h2>
<span class="binding-type">function</span>
<p class="docstring">(pairs x)<br><br>Get the values of an associative data structure.</p>
<span class="source-map">core.janet (32617:32838)</span><hr>
<h2 class="binding">parser&#47;byte</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;byte parser b)<br><br>Input a single byte into the parser byte stream. Returns the parser.</p>
<hr>
<h2 class="binding">parser&#47;consume</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;consume parser bytes [, index])<br><br>Input bytes into the parser and parse them. Will not throw errors if there is a parse error. Starts at the byte index given by index. Returns the number of bytes read.</p>
<hr>
<h2 class="binding">parser&#47;error</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;error parser)<br><br>If the parser is in the error state, returns the message associated with that error. Otherwise, returns nil. Also flushes the parser state and parser queue, so be sure to handle everything in the queue before calling parser&#47;error.</p>
<hr>
<h2 class="binding">parser&#47;flush</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;flush parser)<br><br>Clears the parser state and parse queue. Can be used to reset the parser if an error was encountered. Does not reset the line and column counter, so to begin parsing in a new context, create a new parser.</p>
<hr>
<h2 class="binding">parser&#47;has-more</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;has-more parser)<br><br>Check if the parser has more values in the value queue.</p>
<hr>
<h2 class="binding">parser&#47;new</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;new)<br><br>Creates and returns a new parser object. Parsers are state machines that can receive bytes, and generate a stream of janet values. </p>
<hr>
<h2 class="binding">parser&#47;produce</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;produce parser)<br><br>Dequeue the next value in the parse queue. Will return nil if no parsed values are in the queue, otherwise will dequeue the next value.</p>
<hr>
<h2 class="binding">parser&#47;state</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;state parser)<br><br>Returns a string representation of the internal state of the parser. Each byte in the string represents a nested data structure. For example, if the parser state is &#39;([&quot;&#39;, then the parser is in the middle of parsing a string inside of square brackets inside parentheses. Can be used to augment a REPL prompt.</p>
<hr>
<h2 class="binding">parser&#47;status</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;status parser)<br><br>Gets the current status of the parser state machine. The status will be one of:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:pending - a value is being parsed.<br>&nbsp;&nbsp;&nbsp;&nbsp;:error - a parsing error was encountered.<br>&nbsp;&nbsp;&nbsp;&nbsp;:root - the parser can either read more values or safely terminate.</p>
<hr>
<h2 class="binding">parser&#47;where</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(parser&#47;where parser)<br><br>Returns the current line number and column number of the parser&#39;s location in the byte stream as a tuple (line, column). Lines and columns are counted from 1, (the first byte is line 1, column 1) and a newline is considered ASCII 0x0A.</p>
<hr>
<h2 class="binding">partial</h2>
<span class="binding-type">function</span>
<p class="docstring">(partial f &amp; more)<br><br>Partial function application.</p>
<span class="source-map">core.janet (30252:30371)</span><hr>
<h2 class="binding">peg&#47;compile</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(peg&#47;compile peg)<br><br>Compiles a peg source data structure into a &lt;core&#47;peg&gt;. This will speed up matching if the same peg will be used multiple times.</p>
<hr>
<h2 class="binding">peg&#47;match</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(peg&#47;match peg text [,start=0])<br><br>Match a Parsing Expression Grammar to a byte string and return an array of captured values. Returns nil if text does not match the language defined by peg. The syntax of PEGs are very similar to those defined by LPeg, and have similar capabilities. Still WIP.</p>
<hr>
<h2 class="binding">pos?</h2>
<span class="binding-type">function</span>
<p class="docstring">(pos? x)<br><br>Check if x is greater than 0.</p>
<span class="source-map">core.janet (2046:2100)</span><hr>
<h2 class="binding">postwalk</h2>
<span class="binding-type">function</span>
<p class="docstring">(postwalk f form)<br><br>Do a post-order traversal of a data structure and call (f x)  on every visitation.</p>
<span class="source-map">core.janet (29185:29340)</span><hr>
<h2 class="binding">pp</h2>
<span class="binding-type">function</span>
<p class="docstring">(pp x)<br><br>Pretty print to stdout.</p>
<span class="source-map">core.janet (42432:42502)</span><hr>
<h2 class="binding">prewalk</h2>
<span class="binding-type">function</span>
<p class="docstring">(prewalk f form)<br><br>Similar to postwalk, but do pre-order traversal.</p>
<span class="source-map">core.janet (29343:29461)</span><hr>
<h2 class="binding">print</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(print &amp; xs)<br><br>Print values to the console (standard out). Value are converted to strings if they are not already. After printing all values, a newline character is printed. Returns nil.</p>
<hr>
<h2 class="binding">process&#47;args</h2>
<span class="binding-type">array</span>
<p class="docstring">Command line arguments.</p>
<hr>
<h2 class="binding">product</h2>
<span class="binding-type">function</span>
<p class="docstring">(product xs)<br><br>Returns the product of xs. If xs is empty, returns 1.</p>
<span class="source-map">core.janet (17751:17886)</span><hr>
<h2 class="binding">put</h2>
<span class="binding-type">function</span>
<p class="docstring">(put ds key value)<br><br>Associate a key with a value in any mutable associative data structure. Indexed data structures (arrays and buffers) only accept non-negative integer keys, and will expand if an out of bounds value is provided. In an array, extra space will be filled with nils, and in a buffer, extra space will be filled with 0 bytes. In a table, putting a key that is contained in the table prototype will hide the association defined by the prototype, but will not mutate the prototype table. Putting a value nil into a table will remove the key from the table. Returns the data structure ds.</p>
<hr>
<h2 class="binding">range</h2>
<span class="binding-type">function</span>
<p class="docstring">(range &amp; args)<br><br>Create an array of values [start, end) with a given step.  With one argument returns a range [0, end). With two arguments, returns  a range [start, end). With three, returns a range with optional step size.</p>
<span class="source-map">core.janet (23839:24538)</span><hr>
<h2 class="binding">reduce</h2>
<span class="binding-type">function</span>
<p class="docstring">(reduce f init ind)<br><br>Reduce, also know as fold-left in many languages, transforms  an indexed type (array, tuple) with a function to produce a value.</p>
<span class="source-map">core.janet (21590:21819)</span><hr>
<h2 class="binding">repl</h2>
<span class="binding-type">function</span>
<p class="docstring">(repl chunks onsignal &amp;)<br><br>Run a repl. The first parameter is an optional function to call to  get a chunk of source code that should return nil for end of file.  The second parameter is a function that is called when a signal is  caught.</p>
<span class="source-map">core.janet (51090:51811)</span><hr>
<h2 class="binding">require</h2>
<span class="binding-type">function</span>
<p class="docstring">(require module &amp; args)<br><br>  Require a module with the given name. Will search all of the paths in  module&#47;paths, then the path as a raw file path. Returns the new environment  returned from compiling and running the file.</p>
<span class="source-map">core.janet (48271:50117)</span><hr>
<h2 class="binding">resume</h2>
<span class="binding-type">function</span>
<p class="docstring">(resume fiber [,x])<br><br>Resume a new or suspended fiber and optionally pass in a value to the fiber that will be returned to the last yield in the case of a pending fiber, or the argument to the dispatch function in the case of a new fiber. Returns either the return result of the fiber&#39;s dispatch function, or the value from the next yield call in fiber.</p>
<hr>
<h2 class="binding">reverse</h2>
<span class="binding-type">function</span>
<p class="docstring">(reverse t)<br><br>Reverses the order of the elements in a given array or tuple and returns a new array.</p>
<span class="source-map">core.janet (30560:30822)</span><hr>
<h2 class="binding">run-context</h2>
<span class="binding-type">function</span>
<p class="docstring">(run-context env chunks onstatus where &amp;)<br><br>Run a context. This evaluates expressions of janet in an environment,  and is encapsulates the parsing, compilation, and evaluation of janet.  env is the environment to evaluate the code in, chunks is a function  that returns strings or buffers of source code (from a repl, file,  network connection, etc. onstatus is a callback that is  invoked when a result is returned or any other signal is raised.  This function can be used to implement a repl very easily, simply  pass a function that reads line from stdin to chunks, status-pp to onstatus</p>
<span class="source-map">core.janet (42969:44951)</span><hr>
<h2 class="binding">scan-number</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(scan-number str)<br><br>Parse a number from a byte sequence an return that number, either and integer or a real. The number must be in the same format as numbers in janet source code. Will return nil on an invalid number.</p>
<hr>
<h2 class="binding">seq</h2>
<span class="binding-type">macro</span>
<p class="docstring">(seq head &amp; body)<br><br>Similar to loop, but accumulates the loop body into an array and returns that.  See loop for details.</p>
<span class="source-map">core.janet (16703:16943)</span><hr>
<h2 class="binding">some</h2>
<span class="binding-type">function</span>
<p class="docstring">(some pred xs)<br><br>Returns false if all xs are false or nil, otherwise returns the first true value.</p>
<span class="source-map">core.janet (41185:41386)</span><hr>
<h2 class="binding">sort</h2>
<span class="binding-type">function</span>
<p class="docstring">(sort xs [, by])<br><br>Sort an array in-place. Uses quick-sort and is not a stable sort.</p>
<span class="source-map">core.janet (20764:21469)</span><hr>
<h2 class="binding">sorted</h2>
<span class="binding-type">function</span>
<p class="docstring">(sorted ind by)<br><br>Returns a new sorted array without modifying the old one.</p>
<span class="source-map">core.janet (21472:21587)</span><hr>
<h2 class="binding">status-pp</h2>
<span class="binding-type">function</span>
<p class="docstring">(status-pp sig x f source)<br><br>Pretty print a signal and associated state. Can be used as the  onsignal argument to run-context.</p>
<span class="source-map">core.janet (44954:46232)</span><hr>
<h2 class="binding">stderr</h2>
<span class="binding-type">core/file</span>
<p class="docstring">The standard error file.</p>
<hr>
<h2 class="binding">stdin</h2>
<span class="binding-type">core/file</span>
<p class="docstring">The standard input file.</p>
<hr>
<h2 class="binding">stdout</h2>
<span class="binding-type">core/file</span>
<p class="docstring">The standard output file.</p>
<hr>
<h2 class="binding">string</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string &amp; parts)<br><br>Creates a string by concatenating values together. Values are converted to bytes via describe if they are not byte sequences. Returns the new string.</p>
<hr>
<h2 class="binding">string&#47;ascii-lower</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;ascii-lower str)<br><br>Returns a new string where all bytes are replaced with the lowercase version of themselves in ASCII. Does only a very simple case check, meaning no unicode support.</p>
<hr>
<h2 class="binding">string&#47;ascii-upper</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;ascii-upper str)<br><br>Returns a new string where all bytes are replaced with the uppercase version of themselves in ASCII. Does only a very simple case check, meaning no unicode support.</p>
<hr>
<h2 class="binding">string&#47;bytes</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;bytes str)<br><br>Returns an array of integers that are the byte values of the string.</p>
<hr>
<h2 class="binding">string&#47;check-set</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;check-set set str)<br><br>Checks if any of the bytes in the string set appear in the string str. Returns true if some bytes in set do appear in str, false if no bytes do.</p>
<hr>
<h2 class="binding">string&#47;find</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;find patt str)<br><br>Searches for the first instance of pattern patt in string str. Returns the index of the first character in patt if found, otherwise returns nil.</p>
<hr>
<h2 class="binding">string&#47;find-all</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;find patt str)<br><br>Searches for all instances of pattern patt in string str. Returns an array of all indices of found patterns. Overlapping instances of the pattern are not counted, meaning a byte in string will only contribute to finding at most on occurrence of pattern. If no occurrences are found, will return an empty array.</p>
<hr>
<h2 class="binding">string&#47;from-bytes</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;from-bytes byte-array)<br><br>Creates a string from an array of integers with byte values. All integers will be coerced to the range of 1 byte 0-255.</p>
<hr>
<h2 class="binding">string&#47;join</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;join parts [,sep])<br><br>Joins an array of strings into one string, optionally separated by a separator string sep.</p>
<hr>
<h2 class="binding">string&#47;number</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;number x [,format [,maxlen [,precision]]])<br><br>Formats a number as string. The format parameter indicates how to display the number, either as floating point, scientific, or whichever representation is shorter. format can be:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;:g - (default) shortest representation with lowercase e.<br>&nbsp;&nbsp;&nbsp;&nbsp;:G - shortest representation with uppercase E.<br>&nbsp;&nbsp;&nbsp;&nbsp;:e - scientific with lowercase e.<br>&nbsp;&nbsp;&nbsp;&nbsp;:E - scientific with uppercase E.<br>&nbsp;&nbsp;&nbsp;&nbsp;:f - floating point representation.<br>&nbsp;&nbsp;&nbsp;&nbsp;:F - same as :f<br><br>The programmer can also specify the max length of the output string and the precision (number of places after decimal) in the output number. Returns a string representation of x.</p>
<hr>
<h2 class="binding">string&#47;pretty</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;pretty x [,depth=4 [,buffer=@&quot;&quot;]])<br><br>Pretty prints a value to a buffer. Optionally allows setting max recursion depth, as well as writing to a buffer. Returns the buffer.</p>
<hr>
<h2 class="binding">string&#47;repeat</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;repeat bytes n)<br><br>Returns a string that is n copies of bytes concatenated.</p>
<hr>
<h2 class="binding">string&#47;replace</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;replace patt subst str)<br><br>Replace the first occurrence of patt with subst in the string str. Will return the new string if patt is found, otherwise returns str.</p>
<hr>
<h2 class="binding">string&#47;replace-all</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;replace-all patt subst str)<br><br>Replace all instances of patt with subst in the string str. Will return the new string if patt is found, otherwise returns str.</p>
<hr>
<h2 class="binding">string&#47;reverse</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;reverse str)<br><br>Returns a string that is the reversed version of str.</p>
<hr>
<h2 class="binding">string&#47;slice</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;slice bytes [,start=0 [,end=(length str)]])<br><br>Returns a substring from a byte sequence. The substring is from index start inclusive to index end exclusive. All indexing is from 0. &#39;start&#39; and &#39;end&#39; can also be negative to indicate indexing from the end of the string.</p>
<hr>
<h2 class="binding">string&#47;split</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(string&#47;split delim str)<br><br>Splits a string str with delimiter delim and returns an array of substrings. The substrings will not contain the delimiter delim. If delim is not found, the returned array will have one element.</p>
<hr>
<h2 class="binding">string?</h2>
<span class="binding-type">function</span>
<p class="docstring">(string? x)<br><br>Check if x is a string.</p>
<span class="source-map">core.janet (2337:2401)</span><hr>
<h2 class="binding">struct</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(struct &amp; kvs)<br><br>Create a new struct from a sequence of key value pairs. kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of elements, an error will be thrown. Returns the new struct.</p>
<hr>
<h2 class="binding">struct?</h2>
<span class="binding-type">function</span>
<p class="docstring">(struct? x)<br><br>Check if x a struct.</p>
<span class="source-map">core.janet (2829:2890)</span><hr>
<h2 class="binding">sum</h2>
<span class="binding-type">function</span>
<p class="docstring">(sum xs)<br><br>Returns the sum of xs. If xs is empty, returns 0.</p>
<span class="source-map">core.janet (17621:17748)</span><hr>
<h2 class="binding">symbol</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(symbol &amp; xs)<br><br>Creates a symbol by concatenating values together. Values are converted to bytes via describe if they are not byte sequences. Returns the new symbol.</p>
<hr>
<h2 class="binding">symbol?</h2>
<span class="binding-type">function</span>
<p class="docstring">(symbol? x)<br><br>Check if x is a symbol.</p>
<span class="source-map">core.janet (2403:2467)</span><hr>
<h2 class="binding">table</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table &amp; kvs)<br><br>Creates a new table from a variadic number of keys and values. kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has an odd number of elements, an error will be thrown. Returns the new table.</p>
<hr>
<h2 class="binding">table&#47;getproto</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table&#47;getproto tab)<br><br>Get the prototype table of a table. Returns nil if a table has no prototype, otherwise returns the prototype.</p>
<hr>
<h2 class="binding">table&#47;new</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table&#47;new capacity)<br><br>Creates a new empty table with pre-allocated memory for capacity entries. This means that if one knows the number of entries going to go in a table on creation, extra memory allocation can be avoided. Returns the new table.</p>
<hr>
<h2 class="binding">table&#47;rawget</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table&#47;rawget tab key)<br><br>Gets a value from a table without looking at the prototype table. If a table tab does not contain t directly, the function will return nil without checking the prototype. Returns the value in the table.</p>
<hr>
<h2 class="binding">table&#47;setproto</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table&#47;setproto tab proto)<br><br>Set the prototype of a table. Returns the original table tab.</p>
<hr>
<h2 class="binding">table&#47;to-struct</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(table&#47;to-struct tab)<br><br>Convert a table to a struct. Returns a new struct. This function does not take into account prototype tables.</p>
<hr>
<h2 class="binding">table?</h2>
<span class="binding-type">function</span>
<p class="docstring">(table? x)<br><br>Check if x a table.</p>
<span class="source-map">core.janet (2768:2827)</span><hr>
<h2 class="binding">take-until</h2>
<span class="binding-type">function</span>
<p class="docstring">(take-until pred ind)<br><br>Given a predicate, take only elements from an indexed type that satisfy  the predicate, and abort on first failure. Returns a new array.</p>
<span class="source-map">core.janet (25135:25381)</span><hr>
<h2 class="binding">take-while</h2>
<span class="binding-type">function</span>
<p class="docstring">(take-while pred ind)<br><br>Same as (take-until (complement pred) ind).</p>
<span class="source-map">core.janet (25384:25498)</span><hr>
<h2 class="binding">true?</h2>
<span class="binding-type">function</span>
<p class="docstring">(true? x)<br><br>Check if x is true.</p>
<span class="source-map">core.janet (3610:3658)</span><hr>
<h2 class="binding">try</h2>
<span class="binding-type">macro</span>
<p class="docstring">(try body catch)<br><br>Try something and catch errors. Body is any expression,  and catch should be a form with the first element a tuple. This tuple  should contain a binding for errors and an optional binding for  the fiber wrapping the body. Returns the result of body if no error,  or the result of catch if an error.</p>
<span class="source-map">core.janet (7609:8213)</span><hr>
<h2 class="binding">tuple</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(tuple &amp; items)<br><br>Creates a new tuple that contains items. Returns the new tuple.</p>
<hr>
<h2 class="binding">tuple&#47;append</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(tuple&#47;append tup &amp; items)<br><br>Returns a new tuple that is the result of appending each element in items to tup.</p>
<hr>
<h2 class="binding">tuple&#47;prepend</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(tuple&#47;prepend tup &amp; items)<br><br>Prepends each element in items to tuple and returns a new tuple. Items are prepended such that the last element in items is the first element in the new tuple.</p>
<hr>
<h2 class="binding">tuple&#47;slice</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(tuple&#47;slice arrtup [,start=0 [,end=(length arrtup)]])<br><br>Take a sub sequence of an array or tuple from index start inclusive to index end exclusive. If start or end are not provided, they default to 0 and the length of arrtup respectively.Returns the new tuple.</p>
<hr>
<h2 class="binding">tuple?</h2>
<span class="binding-type">function</span>
<p class="docstring">(tuple? x)<br><br>Check if x is a tuple.</p>
<span class="source-map">core.janet (2956:3017)</span><hr>
<h2 class="binding">type</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(type x)<br><br>Returns the type of x as a keyword symbol. x is one of<br>&nbsp;&nbsp;&nbsp;&nbsp;:nil<br>&nbsp;&nbsp;&nbsp;&nbsp;:boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;:integer<br>&nbsp;&nbsp;&nbsp;&nbsp;:real<br>&nbsp;&nbsp;&nbsp;&nbsp;:array<br>&nbsp;&nbsp;&nbsp;&nbsp;:tuple<br>&nbsp;&nbsp;&nbsp;&nbsp;:table<br>&nbsp;&nbsp;&nbsp;&nbsp;:struct<br>&nbsp;&nbsp;&nbsp;&nbsp;:string<br>&nbsp;&nbsp;&nbsp;&nbsp;:buffer<br>&nbsp;&nbsp;&nbsp;&nbsp;:symbol<br>&nbsp;&nbsp;&nbsp;&nbsp;:keyword<br>&nbsp;&nbsp;&nbsp;&nbsp;:function<br>&nbsp;&nbsp;&nbsp;&nbsp;:cfunction<br><br>or another symbol for an abstract type.</p>
<hr>
<h2 class="binding">unless</h2>
<span class="binding-type">macro</span>
<p class="docstring">(unless condition &amp; body)<br><br>Shorthand for (when (not ... </p>
<span class="source-map">core.janet (5878:5984)</span><hr>
<h2 class="binding">unmarshal</h2>
<span class="binding-type">cfunction</span>
<p class="docstring">(unmarshal buffer [,lookup])<br><br>Unmarshal a janet value from a buffer. An optional lookup table can be provided to allow for aliases to be resolved. Returns the value unmarshalled from the buffer.</p>
<hr>
<h2 class="binding">update</h2>
<span class="binding-type">function</span>
<p class="docstring">(update ds key func &amp; args)<br><br>Accepts a key argument and passes its&#39; associated value to a function.  The key then, is associated to the function&#39;s return value</p>
<span class="source-map">core.janet (31376:31606)</span><hr>
<h2 class="binding">values</h2>
<span class="binding-type">function</span>
<p class="docstring">(values x)<br><br>Get the values of an associative data structure.</p>
<span class="source-map">core.janet (32402:32614)</span><hr>
<h2 class="binding">varglobal</h2>
<span class="binding-type">function</span>
<p class="docstring">(varglobal name init)<br><br>Dynamically create a global var.</p>
<span class="source-map">core.janet (1732:1868)</span><hr>
<h2 class="binding">walk</h2>
<span class="binding-type">function</span>
<p class="docstring">(walk f form)<br><br>Iterate over the values in ast and apply f  to them. Collect the results in a data structure . If ast is not a  table, struct, array, or tuple,  returns form.</p>
<span class="source-map">core.janet (28762:29130)</span><hr>
<h2 class="binding">when</h2>
<span class="binding-type">macro</span>
<p class="docstring">(when condition &amp; body)<br><br>Evaluates the body when the condition is true. Otherwise returns nil.</p>
<span class="source-map">core.janet (5735:5875)</span><hr>
<h2 class="binding">when-let</h2>
<span class="binding-type">macro</span>
<p class="docstring">(when-let bindings &amp; body)<br><br>Same as (if-let bindings (do ;body)).</p>
<span class="source-map">core.janet (18903:19017)</span><hr>
<h2 class="binding">with-idemp</h2>
<span class="binding-type">macro</span>
<p class="docstring">(with-idemp binding form &amp; body)<br><br>Return janet code body that has been prepended  with a binding of form to atom. If form is a non-idempotent  form (a function call, etc.), make sure the resulting  code will only evaluate once, even if body contains multiple  copies of binding. In body, use binding instead of form.</p>
<span class="source-map">core.janet (4120:4732)</span><hr>
<h2 class="binding">with-syms</h2>
<span class="binding-type">macro</span>
<p class="docstring">(with-syms syms &amp; body)<br><br>Evaluates body with each symbol in syms bound to a generated, unique symbol.</p>
<span class="source-map">core.janet (22946:23122)</span><hr>
<h2 class="binding">yield</h2>
<span class="binding-type">function</span>
<p class="docstring">(yield x)<br><br>Yield a value to a parent fiber. When a fiber yields, its execution is paused until another thread resumes it. The fiber will then resume, and the last yield call will return the value that was passed to resume.</p>
<hr>
<h2 class="binding">zero?</h2>
<span class="binding-type">function</span>
<p class="docstring">(zero? x)<br><br>Check if x is zero.</p>
<span class="source-map">core.janet (1998:2044)</span><hr>
<h2 class="binding">zipcoll</h2>
<span class="binding-type">function</span>
<p class="docstring">(zipcoll keys vals)<br><br>Creates an table or tuple from two arrays&#47;tuples.  Returns a new table.</p>
<span class="source-map">core.janet (31096:31373)</span>
</html>

